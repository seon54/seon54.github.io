---
layout: post
comments: true
title: Computer Architecture 1강 ~ 5강 정리
category: Computer Architecture
shortinfo: 컴퓨터의 역사와 구성요소의 역할
tags:
- computer_architecture
---



## 1강 컴퓨터란?

##### 컴퓨터의 정의

- 전자 회로를 이용하여 데이터를 처리하는 장치로 방대한 데이터를 저장하고 자동적으로 계산
- 입력, 제어, 기억, 연산, 출력 기능



##### 컴퓨터가 할 수 있는 일

- 복잡한 계산(미적분, 통계)
- GPU 발전에 따라 초정밀 그래픽 구현 가능
- 네트워크 통신



##### 컴퓨터의 역사

고대

- 계산 도구로서 처음 만들어진 주판
- B.C 3000년 고대 메소포타미아에서 사용
- 17C까지 사용

중세

- 1642년 프랑스 수학자 파스칼이 톱니바퀴 이용한 계산기 발명
- 최초 기계식 게산기
- 기어로 연결된 바퀴판(덧셈, 뺄셈 가능)
- 1671년 독일 라이프니츠가 개량하여 곱셈, 나눗셈도 가능한 계산기 발명(2진법 사용)

근현대

- 19C 영국 찰스 배비지가 차분엔진 발명, 현대 컴퓨터의 개념 처음으로 제시
- 차분 기관과 해석 기관을 설계하여 제어, 연산, 기억, 입출력 가능. 범용적으로 사용된 최초 컴퓨터
- 프로그램과 데이터로 구성된 입력에는 천공카드 사용
- 1930년대 앨런 튜링, 알론조 처치 등이 계산 가능성 및 불가능성에 대해 연구(정지 문제)
- 이를 기반으로 튜링 머신 탄생. 긴 테이프에 부호 기록, 이를 프로그램처럼 사용
- 1941년 독일 콘라드 추제 Z3 발명
- 1945년 폰 노이만 Stored-Program Architecture 제안. 이전까지는 전선을 재배치하여 컴퓨터에게 다른 일을 시켰으나 폰 노이만 이후 S/W를 교체하는 방식 사용
- 1946년 미국 ENIAC 제작(탄도 계산 목적). 10진법 사용, 30t 넘는 무게와 엄청난 전력 소모

현대

- 1960년대: 초기의 다목적 컴퓨터 IBM 시스템/360 개발(초당 34,500 명령 수행, 8~64KB 메모리)
- 1970년대: 톰슨과 리치가 Unix와 C 개발, Intel의 8008 프로세서 개발
- 1980년대: Intel 프로세서와 MS-DOS 사용하는 IBM PC 등장, GUI와 마우스 사용하는 애플 매킨토시 등장
- 1990년대: 리누즈 토발즈의 Linux 개발, Microsoft의 Windows 등장, 인터넷 포털 등장
- 2000년대: 컴퓨터를 활용하여 인간 DNA 염기서열을 밝히는 Genom Project, 애플의 iPhone 필두로 많은 스마트폰 출시(web이 재되어 접근성이 높아지고 web에서 생성된 데이터 증가), 빅데이터와 인공지능의 시대



## 2강 컴퓨터 구조 분야의 8가지 아이디어

##### 8가지 아이디어

1. 무어의 법칙을 고려한 설계

   - 18~24개월마다 칩에 집적되는 소자의 수가 2~4배가 된다는 법칙
   - 시간의 흐름에 따른 컴퓨터의 발전 속도

2. 설계를 단순화하는 추상화

   - 컴퓨터 자원이 많아짐에 따라 설계 시간이 길어짐
   - 설계 기간이 길어지면서 생산성이 낮아짐
   - 생산성을 높이기 위해 추상화 개념 사용
   - 하위 수준의 상세한 사항을 안 보이게 함으로 상위 수준 모델을 단순화

3. Common Case Fast

   - 자주 발생하는 일을 빠르게 처리하여 성능 향상
   - Common Case가 무엇인지 알고 있다는 가정
   - Common Case에 대한 세심함 실험과 측정 필요

4. 병렬성을 통한 성능 개선
   - 문제를 작은 문제로 분할(예: thread)
5. 파이프라이닝을 통한 성능개선
   - 병렬성의 특별한 형태
   - 처음 단계 출력이 다음 단계 입력으로 이어지는 구조
6. 예측을 통한 성능 개선
   - 복구 비용이 낮고 성공확률이 높을 때 효과적
   - 정확한 예측을 위한 지표 필요
7. 메모리 계층 구조
   - 처리 속도가 높은 것부터 낮은 순으로
   - 처리 속도 빨라짐
8. 여유분을 이용한 신용도 개선
   - 컴퓨터는 신뢰할 수 있어야 함
   - 장애대처를 위한 여유분 준비(backup과 같은 이치)



## 3강 컴퓨터의 구성요소 및 역할

컴퓨터의 구성 요소

- 입력(Input)
- 출력(Output)
- 메모리(Memory)
- 데이터 패스(Data Path)
- 제어 유닛(Control Unit)



##### 구성요소별 역할

프로세서

- 메모리로부터 명령과 데이터를 얻음
- 제어 유닛은 프로그램 명령에 따라 데이터 패스, 메모리, 입/출력의 동작 결정

메모리

- 실질적으로 데이터가 저장되는 공간

입력

- 데이터를 메모리에 씀

출력

- 메모리로부터 데이터를 읽음



##### 프로세서

프로세서의 역할: CPU

- 메모리로부터 명령어를 받아와 제어신호 생성
- 기계어를 해석하고 연산
- 컴퓨터 기술을 이끄는 원동력
- 두뇌와 같은 역할

프로세서의 역할: GPU

- 셀로 이루어진 영상을 처리하는 용도
- 싱글코어는 CPU보다 저성능이나 병렬적인 수천개의 코어가 연결되어 있음
- 인공지능 기술발전의 선도주자

프로세서의 동작 과정

- 제어유닛(Control Unit)
  - 명령어를 순서대로 실행하도록 제어
  - 제어 신호 생성 후 주변 장치에 전달
- 레지스터(Register)
  - CPU와 비슷한 속도의 고속 기억 장치, 임시 저장 공간
  - 범용 레지스터: 연산에 필요한 데이터나 연산결과를 임시로 저장하는 레지스터
  - 특수목적 레지스터: 특별한 용도로 사용되는 레지스터
- 산술/논리 연산장치(Arithmetic/Logic Unit, ALU)
  - 산술연산과 논리연산 수행
  - 연산에 필요한 데이터를 레지스터에서 가져오고 결과를 레지스터에 저장



##### 메모리

메모리의 역할

- 명령어(프로세스) 및 데이터 적재
- 정보를 저장해서 필요할 때 읽어들이는 저장소
- 레지스터의 용량이 너무 작아서 출시됨
- RAM, ROM, CACHE 등



##### 입출력장치

입력장치의 역할

- 데이터를 입력하기 위한 컴퓨터의 외부 장치
- 키보드, 마우스, 스캐너 등

출력장치의 역할

- 컴퓨터에서 처리된 결과를 출력해주는 장치
- 모니터, 프린터, 스피커 등



## 4강 기계어, 어셈블리어와 고급어

##### 고급언어

- 일반적으로 언급되는 프로그래밍 언어
- C 언어, Python, Java 등
- 컴파일러가 고급언어를 어셈블리어로 번역

##### 어셈블리어

- 컴파일러로부터 생성된 어셈블리어는 기계어가 이해할 수 있는 형태로 번역됨
- 기계 사고 방식의 언어
- 어셈블러가 어셈블리어를 기계어로 번역

##### 기계어

- 기수가 2인 숫자로 구성
- 비트(bit) 단위

  
##### 시스템 소프트웨어

- 공통적으로 필요한 서비스를 제공하는 소프트웨어
- 운영체제, 컴파일러, 로더, 어셈블러
- 프로그램(application software) - 하드웨어 간의 인터페이스 역할



##### High Level Language

- 기계어를 고도로 추상화한 표현으로 인간이 이해하기 쉬운 형태
- 프로그램을 개발한 기종에 상관없이 어느 컴퓨터에서든 실행 가능
- 컴파일 과정에서 불필요한 instruction이 생성되므로 다소 느림
  - C와 Python을 비교하면 C가 더 적은 assembly instruction이 발생하므로 더 빠르고 용량이 적음

##### Low Level Language

- 컴파일러나 어셈블리어가 생성하는 불필요한 instruction 최소화 가능
- 기계적 사고 방식을 강요하여 프로그램 구성을 위한 소요가 큼
- 효율성 떨어짐



## 5강 성능

##### 성능의 정의

- 시간과 리소스에 대응되어 컴퓨터 시스템이 수행하는 작업의 양
- 다양한 성능 측정 척도(속도, 단위 시간당 처리 양 등)
- 개인 사용자: 응답 시간(Response time)
- 데이터 센터 관리자: 처리량(Throughput)



##### 성능의 척도

응답시간

- 작업 개시부터 종료까지의 시간
- 디스크 접근, 메모리 접근, 입출력 작업, 운영체제 오버헤드, CPU 연산시간 등 포함

처리량

- 단위 시간당 처리할 수 있는 일의 양
- 응답시간과 다른 척도로 시스템 성능을 평가할 때 사용



##### 성능의 측정

성능과 실행시간과의 관계

- 성능 x = 1 / 실행시간 x
- 성능 x > 성능 y일 경우, 실행시간 x < 실행시간y
- 성능x / 성능y = n
- 성능 x = n * 성능y (x가 y보다 n배 빠름)

> 문제 
> 같은 프로그램이 컴퓨터 A에서 10초, B에서는 15초 걸릴 때 A가 B보다 얼마나 빠른가?
>
> ➡️ 성능 a / 성능 b = 실행시간 b / 실행시간 a = n
> ​	   15 / 10 = 1.5



클럭

- 하드웨어 이벤트가 발생하는 시점 결정
- 클럭 사이클: 클럭의 시간 간격
- 클럭 속도: 클럭 사이클의 역수

CPU 성능과 성능 인자

- 궁극적인 CPU 성능 척도는 CPU 시간(입/출력, 다른 프로그램 미포함)
- 프로그램의 CPU 실행시간 = 프로그램의 CPU 클럭 사이클 수 / 클럭 속도
- 클럭 사이클 수 = 명령어 수 * 명령어 당 평균 클럭 사이클 수(CPI)

> 문제
> 2GHz 클럭의 컴퓨터 A에서 10초 수행되는 프로그램이 있다. 이 프로그램을 6초 동안 실행할 컴퓨터 B를 설계하려 할 때 A보다 1.2배 많은 클럭 사이클이 필요하게 된다. 컴퓨터 B의 클럭 속도는?
>
> ➡️ CPU 시간 = 클럭 사이클 수 / 클럭 속도
> ​      10 = 클럭 사이클 수 / 2 * 10^9
> ​      클럭 사이클 수 = 2 * 10^10
> ​      6 = 2 * 10^10 * 1.2 / x
> ​      x = 4 * 2 * 10^9,  클럭 속도 = 4GHz



CPI

- CPI = Clock cycle Per Instruction
- 명령어 하나의 실행에 필요한 평균 클럭 사이클 수
- CPU 클럭 사이클 수 = 명령어 수 * CPI
- 프로그램의 CPU 실행시간 = 명령어 수 * CPI / 클럭 속도
