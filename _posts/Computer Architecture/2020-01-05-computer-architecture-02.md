---
layout: post
comments: true
title: Computer Architecture 6강 ~ 10강 정리
category: Computer Architecture
shortinfo: 전력과 CPU의 발달 과정, 명령어에 대한 정리
tags:
- computer architecture
---



## 6강 전력

##### 전력
- 컴퓨터가 도착하는데에 소비되는 전기의 힘
- 전력과 클럭 속도는 밀접한 관계
- CPU 온도가 낮이지면 전력 소모 감소
- PSU(Power Supply Unit) 통해 전력 공급

##### 클럭 속도와의 관계
- 클럭 속도가 높아지면 전력도 그에 비례하여 높아짐
- 멀티코어 프로세스가 나오면서 클럭 속도를 조금 낮추고 파이프 라인을 단순한 구조로 하여 성능을 높임

##### 전력 사용 주 원인
- 트랜지스터가 0에서 1로 혹은 반대로 스위칭할 때 소비
- 트랜지스터가 소비하는 전력은 스위칭할 때 소모되는 에너지와 시간당 논리값이 바뀌는 빈도수의 곱

##### 문제점
- 전압을 낮추면 트랜지스터 누설 전류 증가
- 전력이 너무 높으면 온도가 올라가 냉각 비용 발생

## 7강 CPU 발전 과정

##### 발전 과정
- 단인 프로세서 ➜ 멀티 코어 프로세서
- 멀티 코어 프로세서: 여러 개의 코어를 집적한 프로세서
- 파이프 라인 구조 채택, 병렬성 상승, 처리량 최대화

##### Intel 8086
- 최초의 16bit 프로세서
- PC가 많이 보급되지 않아 실패
- 가성비가 떨어져 아케이드판, 콘솔 쪽에도 채용되지 못함

##### 80386 CPU
- 386이라는 이름으로 알려짐
- 32bit 아키텍쳐로 이루어진 최초의 CPU
- PC의 보급화로 널리 사용됨

##### 펜티엄
- 숫자 대신 최초로 이름을 가짐
- 클럭 속도: 60MHz ~ 300MHz
- 슈퍼 스칼라 아키텍쳐 사용하여 속도 높임
- 파이프 라인 2개를 사용하여 한 클럭 당 여러 명령어 수행

##### 코어 2
- 최초 멀티 코어 프로세서
- 클럭 속도: 1GHz ~ 3.33GHz
- 코어 개수: 1, 2, 4

##### 암달의 법칙
- 트랜지스터의 증가로 인한 성능 향상에 한계
- 코어 개수를 늘리는 방향으로 CPU 발전
- 멀티 코어가 성능이 2배가 되는 것을 의미하지 않음
- 병렬화 문제에서 기인하여 프로세서 개수만으로는 성능 향상에 한계

##### i3, i5, i7
- i3: 2 cores, 4 threads
- i5: 4 cores, 4 threads
- i7: 4cores, 8 threads
- hyper threading: 하나의 코어에 또 다른 가상 코어를 만들어 CPU를 2개로 인식하게 만드는 병렬화 방법
- overclock(4790K, 7800K)
  - 설계됐을 때의 속도보다 강제로 더 높은 속도로 동작하게 만듦
  - FSB(Front Side Bus)와 CPU 배수를 높여 안정적인 최대 운영 주파수에 다다를 때까지 높임
  - 전력을 많이 소비하게 되지만 높은 사양의 소프트 웨어 사용 가능
  - 발열과 하드웨어에 무리를 주게 됨 

## 8강 명령어

##### 정의
- 컴퓨터가 하드웨어에게 일을 시키기 위한 수단
- 하향식 접근 구조
- 다음 명령어를 가리키는 레지스터(Instruction pointer)에 따라 명령어 실행

##### Instruction pointer
- 현재 실행되고 있는 프로그램의 실행코드가 저장된 메모리 주소를 가리키는 상태 레지스터
- 프로그램의 실행이 진행됨에 따라 자동으로 증가
- 프로그램의 실행 순서가 변경되는 제어문이 실행될 때 자동으로 변경
- 직접 접근 불가

##### 명령어 집합 구조(Instruction Set Architecture)
- 프로세서가 인식해서 기능을 이해하고 실행할 할 수 있는 기계어
- 명령어 집합 구조는 1대1 대응되는 어셈블리어로 표현 가능
- 명령어 집합 구조에는 MIPS, ARM, x86, RISC-V 등이 있음

##### 명령어 집합 구조 설계
- 작성된 프로그램과 수행할 컴퓨터 하드웨어 사이의 인터페이스에 대한 완전한 정의 혹은 명세
- 하드웨어 기술이나 컴퓨터 구성, 플랫폼이 될 운영체제 등을 고려해야 하는 어려운 작업
- 연산 종류: 처리 연산, 제어 연산, 입출력 연산 등
- 데이터 형식: 데이터의 의미, 데이터 값 저장 방식(정수, 실수, 논리) 등
- 명령어 형식: 명령어 구성 부분을 나타내는 양식
- 피연산자를 위한 주소 지정 방식(Addressing mode)
  - 피연산자의 위치를 명시하는 방법
  - 메모리 또는 레지스터

##### 구조
- 실행코드(opcode)와 피연산자(operand)로 구성
- 총 32bit로 8bit 블럭 4개로 구성
- 첫 4bit는 실행코드, 나머지는 피연산자

## 9강 하드웨어 연산

##### 산술연산
- 덧셈, 뺄셈, 곱셈, 나눗셈의 사칙 연산
- 컴퓨터는 레지스터와 ALU를 통해 산술연산 수행

##### MIPS 산술 명령어
- 반드시 한 종류의 연산만 지시
- 항상 변수 3개를 가짐
- 간단하게 설계하기 위해서는 규칙적인 것이 좋으므로 피연산자는 항상  3개
  ```markdown
  MIPS 산술 명령어를 통해 b, c, d, e의 합을 a에 넣는 경우
  	1) b와 c를 더하여 a에 저장
  		add a, b, c
      2) a와 d를 더하여 a에 저장 
      	add a, a, d
      3) a와 e를 더하여 a에 저장 
      	add a, a, e
  ```

##### MIPS 레지스터
- 연산을 위해 MIPS 명령어 구조에서 제공하는 레지스터
- 컴퓨터가 사용하는 변수 역할      

##### 스택 프레임
- 함수가 실행될 때마다 자신만의 고유한 stack 영역 가짐
- 함수의 스택 프레임 시작점은 fp가 가리킴
- 함수의 종료시에 해제되고 리턴 주소로 복귀

##### 고급 언어와의 관계
- 변수는 s 레지스터에 저장
- A ~ E는 $s1 ~ $s5에 저장되어 있다고 가정

```c
A = B + C;
D = A - E;
```
```markdown
add $s1, $s2, $s3
sub $s4, $s1, $s5
```

## 10강 피연산자

##### 피연산자
- 연산자에 정의된 연산을 하기 위해 사용되는 레지스터나 상수, 레이블, 메모리 주소
- 레지스터는 데이터를 저장하는 장치 중 속도가 가장 빠른 장소이므로 일부 레지스터만 사용 가능
- 더 적은 레지스터를 필요로 하는 순서로 연산을 함으로써 더 많은 피연산자를 레지스터에 할당할 수 있게 됨

##### 데이터 단위
| 데이터 단위 |  크기  |
| :---------: | :----: |
|    word     | 32 bit |
|  half word  | 16 bit |
|    byte     | 8 bit  |
- MIPS 명령어 및 레지스터는 32 bit로 구성

##### 메모리 피연산자
- 프로그래밍 언어에는 단순 변수가 아닌 자료형 존재(ex. 구조체, 배열)
- 레지스터는 소량의 데이터만 저장할 수 있으므로 나머지 데이터는 메모리(heap-동적으로 할당, stack-정적으로 할당)에 저장 후 주소에 접근하여 사용
- 메모리와 레지스터간 데이터를 주고받는 명령어를 데이터 전송 명령어(Data Transfer Instruction)이라 함

##### 적재 명령어
- 메모리에서 레지스터로 데이터를 복사하는 데이터 명령어
- 메모리는 주소가 인덱스의 역할을 하는 일차원 구조
- 연산자(lw) + 값을 저장할 레지스터 + 메모리 접근에 사용할 상수 및 레지스터로 구성
  ```
  MIPS 명령어로 치환하기
   1) g, h는 각각 $s1, $s2에 할당
   2) 배열 A의 시작주소는 $s3에 할당
  	g = h + A[1];
  	
  lw $t0, 4($s3)			# $t0 = Memory[$s3 + 4]
  add $s1, $s2, $t0		# $s1 = $s2 + $t0
   
   - 데이터 전송 명령어 상수 부분(4)를 offset이라 함
   - 자료구조의 시작 주소를 가리키는 레지스터를 bare register라 함
   - MIPS에서 시작 주소는 항상 4의 배수여야 함(정렬 제약)
  ```

##### 저장 명령어
- 적재와 반대로 레지스터에서 메모리로 데이터를 보내는 명령어
- 적재 명령어와 같은 구조
- 연산자(sw) + 저장할 데이터를 가진 레지스터 + 메모리 주소 레지스터 및 상수(offset)로 구성
  ```
  MIPS 명령어를 C언어로 치환하기
    1) h는 $s1에 할당
    2) 배열 A의 시작 주소는 $s3에 할당
  	lw $t0, 8($s3)
  	add $t0, $s1, $t0
  	sw $t0, 32($s3)
  	
  A[8] = h + A[2]
  
   - 배열 A의 인덱스 2에 접근하기 위해 2*4 = 8을 $S3에 더함 ➜ 8($s3)
   - 배열 A의 인덱스 2의 값을 임시 레지스터 $t0에 저장 ➜ lw $t0, 8($s3)
   - $s1에 저장된 h의 값과 add 연산 ➜ add $t0, $s1, $t0
   - sw 연산을 이용하여 A[8]에 값을 저장하기 위해 베이스 레지스터에 8*4 = 32의 값을 더함 ➜ sw $t0, 32($s3)
  ```

##### 수치 연산
- 프로그램 연산에서 레지스터가 아닌 상수를 사용하는 경우
- 상수 필드를 갖는 산술 명령어를 사용시 메모리에서 적재하는 것보다 효율적
- 사용 빈도가 높으면 상수를 명령어에 포함하는 것이 좋음(Common case fast)
- 연산자: addi(add와 같은 구조)
  ```
  MIPS 명령어로 치환하기
   1) h는 $s1에 저장되어 있음
   2) 배열 A의 베이스 레지스터는 $s3
   	A[8] = h + 10
   	
  addi $t0, $s1, 10		# $t0 = h + 10
  sw $t0, 32($s3)			# A[8] = $t0
  ```
