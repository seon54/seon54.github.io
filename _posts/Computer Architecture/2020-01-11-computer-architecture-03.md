---
layout: post
comments: true
title: Computer Architecture 11강 ~ 12강 정리
category: Computer Architecture
shortinfo: 
tags:
- computer architecture
---



## 11강 부호

##### 컴퓨터의 숫자 표현

- 높고 낮음만이 존재하는 디지털 신호(클럭 펄스)형태의 2진 숫자 체계 사용
- 진법을 나타내는 기본수를 기수라고 함
- 123(기수 10), 1101(기수 2) 
- 모든 정보는 bit로 구성

##### 이진수의 십진수 변환

- MIPS word 길이는 4byte(32bit)이므로 최대 2^32 -1까지 표현 가능

##### 음수의 표현

- 컴퓨터는 양수와 음수 전부 사용
- 부호를 표현하기 위해 2의 보수 사용

##### 보수(역 부호화)

- 양수에 대한 음의 값
- 1의 보수: NOT(전체 비트)
- 2의 보수: 1의 보수 + 1(1의 보수는 0이 2개 존재)
- 2의 보수를 취하면 MSB가 부호를 나타냄(부호 비트)
  - 0일 경우 양수
  - 1일 경우 음수
- 범위: -2,147,483,648 ~ 2,147,483,647

##### 오버 플로우(Overflow)

- 덧/뺄셈 연산 결과가 처리할 수 있는 최대 비트수를 초과할 때 발생
- 더하거나 빼는 두 수의 부호가 동일하며 결과가 반대 부호일 때
- 캐리(자리올림수): 오버플로우는 아니면서 가장 높은 자리(MSB)에서 자리 올림이 발생한 경우로 2의 보수 연산에서는 무시함



## 12강 명령어의 컴퓨터 내부 표현

##### 명령어 해석 방법

- 명령어도 높고 낮은 전기 신호의 연속이므로 숫자로 표현 가능
- 레지스터가 명령어에서 참조되기 때문에 레지스터 이름을 숫자로 매핑하는 규칙 존재
- $s0 ~ $s7 == 16 ~ 23
- $t0 ~ $T7 == 8 ~ 15

##### 어셈블리어의 기계어 변환

- op: 명령어가 실행할 연산의 종류로 연산자
- rs: 첫번재 근원지(source) operand 레지스터
- rt: 두번째 근원지 operand 레지스터
- rd: 목적지 레지스터로 연산결과 기억
- shamt: 자리이동량 shift 명령어를 배우기 전까지 0으로 사용
- funct: op 코드에 표시된 연산의 구체적 종류 지정

##### 명령어 타입

- R 타입: 오른쪽 절판 필드가 3개일 경우
- I 타입: 오른쪽 절반 필드가 1개일 경우
- address는 16비트 주소
- 명령어 형식이 여러가지가 되면 복잡해지지만 유사하게 설계하여 복잡도를 낮춤