---
layout: post
comments: true
title: Computer Architecture 13강 ~ 15강 정리
category: Computer Architecture
shortinfo: 논리 명령어, 조건부 분기 명령어, 프로시저 정리
tags:
- computer architecture
---



## 13강 논리 명령어

##### 정의

- AND, NOR, OR 등의 논리 연산을 하기 위한 명령어
- 초기의 컴퓨터는 워드 전체에 대한 처리에만 관심을 가졌으나 비트 일부나 비트 개개에 대한 연산이 필요함을 깨달음
- 비트들을 워드로 묶는 packing, 워드를 비트 단위로 나누는 unpacing 작업 수행

##### 종류

|  연산자   | 고급언어 표현 |     수행동작     |
| :-------: | :-----------: | :--------------: |
|    sll    |      <<       |  비트 왼쪽 이동  |
|    srl    |      \>>      | 비트 오른쪽 이동 |
| and, andi |       &       | 비트 간 and 연산 |
|  or, ori  |      \|       | 비트 간 or 연산  |
|    nor    |       ~       |   not, or 연산   |

##### 시프트 연산자

- 비트를 오른쪽으로 4칸 이동
- 만약 지정된 비트수를 넘겼을 경우에는 최하위 비트는 버려짐

```shell
srl $t2, $s0, 4

0001 0000 → 0000 0001 
1000 1000 → 0000 1000
```

##### 논리 연산자

| AND  |  T   |  F   |
| :--: | :--: | :--: |
|  T   |  1   |  0   |
|  F   |  0   |  0   |

| OR  |  T   |  F   |
| :--: | :--: | :--: |
|  T   |  1   |  1  |
|  F   |  1  |  0   |

| XOR  |  T   |  F   |
| :--: | :--: | :--: |
|  T   |  0   |  1   |
|  F   |  1   |  0   |

| NOR  |  T   |  F   |
| :--: | :--: | :--: |
|  T   |  0   |  0   |
|  F   |  0   |  1   |

```
1010 OR 0101 = 1111
1010 AND 1001 = 1000
1010 NOR 0010 = 0101
1001 XOR 0110 = 1111
```



## 14장 판단을 위한 명령어

##### 조건부 분기

- 컴퓨터와 단순 계산기의 차이점은 판단 기능이 있다는 점
- 입력데이터나 연산 결과에 따라 다른 명령어 실행 가능
- 고급언어 예: if, go to, switch
- MIPS에서는 if-then-else를 이용하여 간단하게 swtich문을 구현 가능

##### 조건부 분기 명령어

- beq(branch if equal): 비교 레지스터 값이 같을 경우 L1으로 분기
- bne(branch if not equal): 비교 레지스터 값이 다를 경우 L1으로 분기
- 조건이 많을수록 bne가 명령이 적어 더 효율적

```shell
beq register1, register2, L1
bne register1, register2, L2
```

##### 반복문(loop)

- 계산의 반복적인 수행을 위하여 명령의 순환이 필요
- 고급언어 예: for, while

##### 대소 비교

- equl, not equal외에 변수 간에 대소 비교 존재
- slt, slti 명령어 이용
- 첫번째 근원지 레지스터와 두번째 근원지 레지스터를 비교하여 첫번째가 작을 경우 목적지 레지스터를 1로 , 아닐 경우 0으로 설정
- 부호없는 수(unsigend number)끼리의 비교는 sltu, sltiu 사용

```shell
if (rs<rt) rd=1;
else if(rs>rt) rd=0;
```



## 15강 프로시저

##### 프로시저

- 제공되는 인수에 따라 특정 작업을 수행하는 서브 루틴
- 프로시저의 인수는 프로시저에 값을 보내고 결과를 받음
- 프로시저나 함수는 재사용 할 수 있도록 프로그램을 구조화

##### 프로시저 관련 레지스터

- $a0 - $a3: 전달할 인수를 갖는 인수 레지스터
- $v0 - $v1: 반환되는 값을 갖는 값 레지스터
- $ra: 복귀주소(return address)를 가지는 레지스터

##### 명령어

- jal(jump-and-link)

- 복귀주소를 $ra에 저장하고 프로시저가 할당된 주소로 점프

- $ra의 주소로 복귀할 때는 jr(jump register) 사용

  ```shell
  jal procedure address, jr $ra
  ```

##### 실행단계

1. 프로시저가 접근할 수 있는 곳에 인수를 넣는다.
2. 프로시저로 제어를 넘긴다.
3. 프로시저가 필요로 하는 메모리 자원을 획득한다.
4. 필요한 작업을 수행한다.
5. 호출한 프로그램이 접근할 수 있는 레지스터에 결과값을 넘긴다.
6. 호추한 프로그램으로 제어권을 반환한다.

##### 스택

- 레지스터가 부족할 때 사용
- push, pop으로 데이터를 넣고 꺼냄
- 스택포인터(sp)의 값은 스택에서 데이터가 들어가고 나올 때마다 변경
- 스택은 높은 주소에서 낮은 주소로 생성되므로 스택을 할당할 때에는 sp에서 사용할만큼의 값을 감소시켜야 함

##### 스택 프레임

- 각 프로시저는 독립된 스택프레임을 갖고 있음
- 프로시저의 저장된 레지스터와 지역변수를 가지고 있는 스택 영역
- 프레임 포인터(fp)가 프로시저의 첫번째 워드를 가리키도록 되어 있음
- fp는 베이스 레지스터의 역할을 하고 sp는 값이 변경되며 스택의 최하단을 가리킴
- 재귀호출 등에서 ra값이 변경될 여지가 있으므로 복귀주소 저장 수단으로 사용

##### segment

- 메모리는 각각 다른 값을 저장하는 블록으로 나누어짐
- Stack: 지역변수 선언, 정적 할당, 프로그램 종료시 자동 소멸
- Heap: 동적으로 할당된 메모리 영역, 개발자가 해제(free)해야 함
- Segmentation fault: 참조할 수 없는 메모리 영역을 참조할 때 발생하는 에러